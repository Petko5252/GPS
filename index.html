<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPS Navigation</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>
    
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 10; }
        .user-location-icon svg { filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4)); transition: transform 0.3s ease-out; }
        .loader { border: 4px solid #f3f3f320; border-top: 4px solid #3B82F6; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Style for traffic layer toggle button */
        #traffic-btn.active { background-color: #3B82F6; color: white; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 overflow-hidden">

    <div id="map"></div>

    <div class="relative z-20 h-screen w-screen flex flex-col p-4 md:p-6 gap-4 pointer-events-none">
        
        <div id="search-container" class="w-full max-w-md mx-auto pointer-events-auto">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg flex flex-col">
                <div class="flex items-center gap-2 p-3">
                    <i class="ph ph-magnifying-glass text-gray-400 text-xl"></i>
                    <input type="text" id="search-input" placeholder="Search for a destination..." class="w-full bg-transparent focus:outline-none text-gray-800 dark:text-gray-200">
                    <div id="loader" class="loader hidden"></div>
                </div>
                <div id="search-results" class="border-t border-gray-200 dark:border-gray-700 max-h-60 overflow-y-auto"></div>
            </div>
        </div>
        
        <div id="navigation-panel" class="hidden w-full max-w-md mx-auto pointer-events-auto bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4">
             <div class="flex items-center gap-4">
                 <div id="next-maneuver-icon" class="text-blue-500 text-4xl"></div>
                 <div class="flex-grow">
                     <p id="next-maneuver-dist" class="text-xl font-bold text-gray-800 dark:text-gray-200">...</p>
                     <p id="next-maneuver-text" class="text-gray-600 dark:text-gray-400">...</p>
                 </div>
                 <div id="eta-distance" class="text-right">
                     <p id="eta-text" class="text-xl font-bold text-gray-800 dark:text-gray-200">--:--</p>
                     <p id="distance-text" class="text-gray-600 dark:text-gray-400">0 km</p>
                 </div>
             </div>
        </div>
        
        <div class="flex-grow"></div> <div class="absolute right-4 md:right-6 bottom-36 flex flex-col gap-3 pointer-events-auto">
             <button id="recenter-btn" title="Recenter Map" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-crosshair text-2xl"></i></button>
             <button id="traffic-btn" title="Toggle Traffic" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-traffic-signal text-2xl"></i></button>
             <button id="mute-btn" title="Toggle Voice" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i id="mute-icon" class="ph-bold ph-speaker-high text-2xl"></i></button>
             <button id="dark-mode-toggle" title="Toggle Theme" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-sun text-2xl dark:hidden"></i><i class="ph-bold ph-moon text-2xl hidden dark:inline"></i></button>
        </div>

        <div class="flex flex-col items-center pointer-events-auto">
            <div id="travel-mode-selector" class="bg-white dark:bg-gray-800 p-2 rounded-full shadow-lg flex gap-2 mb-4">
                <button data-mode="driving" class="travel-mode-btn active bg-blue-500 text-white rounded-full px-4 py-2 flex items-center gap-2"><i class="ph-bold ph-car"></i><span>Driving</span></button>
                <button data-mode="walking" class="travel-mode-btn bg-transparent text-gray-600 dark:text-gray-300 rounded-full px-4 py-2 flex items-center gap-2"><i class="ph-bold ph-person"></i><span>Walking</span></button>
                <button data-mode="cycling" class="travel-mode-btn bg-transparent text-gray-600 dark:text-gray-300 rounded-full px-4 py-2 flex items-center gap-2"><i class="ph-bold ph-bicycle"></i><span>Cycling</span></button>
            </div>
            
            <div id="bottom-panel" class="w-full max-w-2xl mx-auto">
                 <div id="status-panel" class="bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-4 text-center"><p id="status-text" class="text-gray-700 dark:text-gray-300 font-medium">Initializing GPS...</p></div>
                 <div id="route-summary-panel" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-4 flex flex-col gap-4">
                      <div>
                          <p class="text-2xl font-bold text-gray-800 dark:text-gray-200" id="summary-duration">-- min</p>
                          <p class="text-gray-500 dark:text-gray-400" id="summary-distance">-- km</p>
                      </div>
                      <button id="start-nav-btn" class="bg-blue-500 text-white font-bold py-3 w-full rounded-lg hover:bg-blue-600">Start</button>
                 </div>
                 <div id="directions-container" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-h-[40vh] flex flex-col">
                     <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0"><h2 class="text-lg font-bold text-gray-800 dark:text-gray-200">Directions</h2></div>
                     <div id="directions-panel" class="overflow-y-auto p-4 flex-grow text-gray-700 dark:text-gray-300"></div>
                     <button id="end-nav-btn" class="bg-red-500 text-white font-bold py-3 w-full rounded-b-xl hover:bg-red-600">End Navigation</button>
                 </div>
            </div>
        </div>
    </div>

    <script>
        const dom = {
            mapContainer: document.getElementById('map'), statusText: document.getElementById('status-text'),
            searchInput: document.getElementById('search-input'), searchResults: document.getElementById('search-results'),
            loader: document.getElementById('loader'), recenterBtn: document.getElementById('recenter-btn'),
            darkModeToggle: document.getElementById('dark-mode-toggle'), navigationPanel: document.getElementById('navigation-panel'),
            etaText: document.getElementById('eta-text'), distanceText: document.getElementById('distance-text'),
            statusPanel: document.getElementById('status-panel'), directionsContainer: document.getElementById('directions-container'),
            directionsPanel: document.getElementById('directions-panel'), endNavBtn: document.getElementById('end-nav-btn'),
            travelModeSelector: document.getElementById('travel-mode-selector'), searchContainer: document.getElementById('search-container'),
            routeSummaryPanel: document.getElementById('route-summary-panel'), startNavBtn: document.getElementById('start-nav-btn'),
            summaryDuration: document.getElementById('summary-duration'), summaryDistance: document.getElementById('summary-distance'),
            nextManeuverIcon: document.getElementById('next-maneuver-icon'), nextManeuverDist: document.getElementById('next-maneuver-dist'),
            nextManeuverText: document.getElementById('next-maneuver-text'), trafficBtn: document.getElementById('traffic-btn'),
            muteBtn: document.getElementById('mute-btn'), muteIcon: document.getElementById('mute-icon'),
        };

        const state = {
            map: null, userMarker: null, routeLayer: null, destinationMarker: null, watchId: null,
            currentLocation: null, isNavigating: false, searchTimeout: null, currentTravelMode: 'driving',
            lightTileLayer: null, darkTileLayer: null, trafficLayer: null, isMuted: false,
            etaInterval: null, routeData: null,
        };

        function initMap() {
            if (!navigator.geolocation) {
                dom.statusText.textContent = "Geolocation is not supported."; return;
            }
            state.map = L.map(dom.mapContainer, { zoomControl: false }).setView([51.505, -0.09], 13);
            L.control.zoom({ position: 'bottomright' }).addTo(state.map);

            state.lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap' });
            state.darkTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '© OSm, © CartoDB' });
            
            // DEBUG FIX: The traffic layer requires a valid API key and correct URL from a provider like HERE, TomTom, or Mapbox.
            // The original URL was malformed. It's now initialized with a blank URL to prevent errors.
            // To enable it, get an API key and use the provider's correct TileLayer URL.
            // Example for HERE Maps: 'https://2.traffic.maps.ls.hereapi.com/maptile/2.1/flowtile/newest/normal.day/{z}/{x}/{y}/256/png8?apiKey={YOUR_API_KEY}'
            state.trafficLayer = L.tileLayer(''); 
            
            if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark'); state.darkTileLayer.addTo(state.map);
            } else { state.lightTileLayer.addTo(state.map); }
            dom.statusText.textContent = "Acquiring your location...";
            startWatchingPosition();
            setupEventListeners();
        }

        function setupEventListeners() {
            state.map.on('click', onMapClick);
            dom.endNavBtn.addEventListener('click', endNavigation);
            dom.startNavBtn.addEventListener('click', startNavigation);
            dom.recenterBtn.addEventListener('click', () => state.currentLocation && state.map.setView(state.currentLocation, 16, { animate: true }));
            dom.darkModeToggle.addEventListener('click', toggleDarkMode);
            dom.trafficBtn.addEventListener('click', toggleTraffic);
            dom.muteBtn.addEventListener('click', toggleMute);
            dom.searchInput.addEventListener('input', () => { clearTimeout(state.searchTimeout); state.searchTimeout = setTimeout(performSearch, 500); });
            dom.travelModeSelector.addEventListener('click', (e) => {
                const button = e.target.closest('.travel-mode-btn');
                if (!button || state.isNavigating) return;
                
                if (button.classList.contains('active')) return;

                state.currentTravelMode = button.dataset.mode;
                
                document.querySelectorAll('.travel-mode-btn').forEach(btn => {
                    btn.classList.remove('active', 'bg-blue-500', 'text-white');
                    btn.classList.add('bg-transparent', 'text-gray-600', 'dark:text-gray-300');
                });
                
                button.classList.remove('bg-transparent', 'text-gray-600', 'dark:text-gray-300');
                button.classList.add('active', 'bg-blue-500', 'text-white');
                
                if (state.destinationMarker) {
                    getRoute(state.currentLocation, state.destinationMarker.getLatLng());
                }
            });
        }
        
        function startWatchingPosition() {
            const options = { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 };
            state.watchId = navigator.geolocation.watchPosition(onPositionUpdate, (e) => dom.statusText.textContent = "Could not get your location. Please enable GPS.", options);
        }

        function onPositionUpdate(position) {
            const { latitude, longitude, heading } = position.coords;
            state.currentLocation = { lat: latitude, lng: longitude };
            if (!state.userMarker) {
                state.map.setView(state.currentLocation, 16);
                const userIconHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><path fill="#3B82F6" d="M232,128A104,104,0,0,1,38.26,169.87L25.47,225.1a16,16,0,0,1-20-20L60.13,192.31A104,104,0,1,1,232,128Z"></path></svg>`;
                state.userMarker = L.marker(state.currentLocation, { icon: L.divIcon({ className: 'user-location-icon', html: userIconHTML, iconSize: [28, 28] }) }).addTo(state.map);
                dom.statusText.textContent = "Tap map or search to set destination.";
            } else {
                state.userMarker.setLatLng(state.currentLocation);
                if (state.isNavigating) state.map.panTo(state.currentLocation, { animate: true });
            }
            if (heading !== null) {
                const iconElement = state.userMarker.getElement()?.querySelector('svg');
                if(iconElement) iconElement.style.transform = `rotate(${heading}deg)`;
            }
        }

        function toggleDarkMode() {
            document.documentElement.classList.toggle('dark');
            const isDark = document.documentElement.classList.contains('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            state.map.removeLayer(isDark ? state.lightTileLayer : state.darkTileLayer);
            (isDark ? state.darkTileLayer : state.lightTileLayer).addTo(state.map);
        }
        
        function toggleTraffic() {
            if (!state.trafficLayer || !state.trafficLayer.options.maxZoom) { // A simple check if the layer is configured
                alert("Traffic layer is not configured. Please add a valid TileLayer URL in the code.");
                return;
            }
            if (state.map.hasLayer(state.trafficLayer)) {
                state.map.removeLayer(state.trafficLayer);
                dom.trafficBtn.classList.remove('active');
            } else {
                state.trafficLayer.addTo(state.map);
                dom.trafficBtn.classList.add('active');
            }
        }
        
        function toggleMute() {
            state.isMuted = !state.isMuted;
            dom.muteIcon.className = state.isMuted ? 'ph-bold ph-speaker-slash text-2xl' : 'ph-bold ph-speaker-high text-2xl';
            if (!state.isMuted) speak("Voice guidance enabled.");
        }

        function speak(text) {
            if (state.isMuted || !('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            window.speechSynthesis.speak(utterance);
        }

        async function performSearch() {
            const query = dom.searchInput.value;
            if (query.length < 3) { dom.searchResults.innerHTML = ''; return; }
            dom.loader.classList.remove('hidden');
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5`);
                const data = await response.json();
                dom.searchResults.innerHTML = data.length === 0 ? `<div class="p-3 text-gray-500">No results found.</div>` : data.map(result => `
                    <div class="p-3 border-b border-gray-200 dark:border-gray-700 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" data-lat="${result.lat}" data-lon="${result.lon}">
                        <p class="font-semibold text-gray-800 dark:text-gray-200">${result.display_name.split(',')[0]}</p>
                        <p class="text-sm text-gray-500 dark:text-gray-400">${result.display_name.substring(result.display_name.indexOf(',') + 1)}</p>
                    </div>`).join('');
                dom.searchResults.querySelectorAll('div[data-lat]').forEach(item => item.addEventListener('click', (e) => {
                    setDestination({ lat: e.currentTarget.dataset.lat, lng: e.currentTarget.dataset.lon });
                    dom.searchInput.value = ''; dom.searchResults.innerHTML = '';
                }));
            } catch (error) { dom.searchResults.innerHTML = `<div class="p-3 text-red-500">Search failed.</div>`; } 
            finally { dom.loader.classList.add('hidden'); }
        }
        
        function onMapClick(e) { if (state.isNavigating) return; setDestination(e.latlng); }

        function setDestination(latlng) {
            if (state.destinationMarker) { state.destinationMarker.setLatLng(latlng); } 
            else { state.destinationMarker = L.marker(latlng).addTo(state.map).bindPopup("Destination").openPopup(); }
            if (state.currentLocation) getRoute(state.currentLocation, latlng);
            else dom.statusText.textContent = "Waiting for location to get route.";
        }
        
        async function getRoute(start, end) {
            dom.loader.classList.remove('hidden');
            dom.statusText.textContent = "Calculating route...";
            dom.statusPanel.classList.remove('hidden');
            dom.routeSummaryPanel.classList.add('hidden');

            // DEBUG FIX: Map the UI travel mode to the correct OSRM profile name.
            const osrmProfiles = { driving: 'car', walking: 'foot', cycling: 'bike' };
            const profile = osrmProfiles[state.currentTravelMode] || 'car'; // Default to car if something goes wrong.

            const url = `https://router.project-osrm.org/route/v1/${profile}/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson&steps=true`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Routing service failed: ${response.status} ${errorText}`);
                }

                const data = await response.json();
                
                if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                    state.routeData = data.routes[0];
                    if (state.routeLayer) state.map.removeLayer(state.routeLayer);
                    const latLngs = state.routeData.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    state.routeLayer = L.polyline(latLngs, { color: '#3B82F6', weight: 6, opacity: 0.8 }).addTo(state.map);
                    state.map.fitBounds(state.routeLayer.getBounds(), { padding: [100, 100] });
                    showRouteSummary(state.routeData);
                } else { 
                    dom.statusText.textContent = data.message || "Could not find a route. Try a different travel mode.";
                }
            } catch (error) { 
                console.error("Error fetching route:", error);
                dom.statusText.textContent = "Error calculating route. Please check connection."; 
            }
            finally { 
                dom.loader.classList.add('hidden'); 
            }
        }
        
        function showRouteSummary(route) {
            const durationMin = Math.round(route.duration / 60);
            const distanceKm = (route.distance / 1000).toFixed(1);
            dom.summaryDuration.textContent = `${durationMin} min`;
            dom.summaryDistance.textContent = `${distanceKm} km`;
            dom.statusPanel.classList.add('hidden');
            dom.routeSummaryPanel.classList.remove('hidden');
        }

        function startNavigation() {
            if (!state.routeData) return;
            state.isNavigating = true;
            dom.searchContainer.classList.add('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.navigationPanel.classList.remove('hidden');
            dom.directionsContainer.classList.remove('hidden');
            dom.travelModeSelector.classList.add('hidden');
            if (state.destinationMarker) state.destinationMarker.closePopup();

            displayDirections(state.routeData.legs[0].steps);
            state.routeData.startTime = Date.now();
            updateNavDisplay();
            state.etaInterval = setInterval(updateNavDisplay, 5000);
        }

        function updateNavDisplay() {
            if (!state.isNavigating || !state.routeData) return;
            const elapsedTime = (Date.now() - state.routeData.startTime) / 1000;
            const remainingDuration = Math.max(0, state.routeData.duration - elapsedTime);
            const eta = new Date(Date.now() + remainingDuration * 1000);
            dom.etaText.textContent = eta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            // Note: This is a simplified distance calculation based on time. 
            // A more accurate method would recalculate based on the user's progress along the route polyline.
            const distanceTraveledRatio = Math.min(1, elapsedTime / state.routeData.duration);
            const remainingDistance = state.routeData.distance * (1 - distanceTraveledRatio);
            dom.distanceText.textContent = `${(remainingDistance / 1000).toFixed(1)} km`;
        }

        function getInstruction(step) {
            if (step.maneuver && step.maneuver.instruction) {
                return step.maneuver.instruction;
            }
            
            if (step.maneuver && step.maneuver.type === 'arrive') {
                let direction = step.maneuver.modifier || '';
                if (direction) { direction = `on your ${direction.replace('-', ' ')}`; }
                const destinationName = step.name ? `at ${step.name}` : 'at your destination';
                return `You have arrived ${destinationName}, ${direction}`.trim().replace(/,$/, ''); 
            }

            const type = (step.maneuver.type || '').replace(/([A-Z])/g, ' $1').toLowerCase();
            const modifier = step.maneuver.modifier || '';
            const road = step.name ? `onto ${step.name}` : '';
            return `${type} ${modifier} ${road}`.replace(/\s+/g, ' ').trim();
        }

        function getManeuverIcon(type, modifier) {
            // DEBUG FIX: Expanded icon mapping for more direction types.
            const icons = {
                'depart': 'ph-navigation-arrow',
                'turn': {
                    'uturn': 'ph-arrow-u-up-left', 'sharp right': 'ph-arrow-elbow-right', 'right': 'ph-arrow-bend-up-right',
                    'slight right': 'ph-arrow-bend-up-right', 'straight': 'ph-arrow-up', 'slight left': 'ph-arrow-bend-up-left',
                    'left': 'ph-arrow-bend-up-left', 'sharp left': 'ph-arrow-elbow-left',
                },
                'fork': { 'right': 'ph-git-fork', 'left': 'ph-git-fork', 'straight': 'ph-arrow-up' },
                'end of road': 'ph-sign-t',
                'use lane': 'ph-arrow-line-up',
                'merge': 'ph-arrows-merge',
                'ramp': 'ph-arrow-up-right',
                'roundabout': 'ph-radio-button',
                'rotary': 'ph-radio-button',
                'continue': 'ph-arrow-up',
                'arrive': 'ph-check-circle',
                'new name': 'ph-arrow-up',
                'default': 'ph-question'
            };
            let iconClass = icons.default;
            if (icons[type]) {
                if (typeof icons[type] === 'string') {
                    iconClass = icons[type];
                } else if (typeof icons[type] === 'object' && icons[type][modifier]) {
                    iconClass = icons[type][modifier];
                } else if (typeof icons[type] === 'object') {
                    // Fallback for turn/fork if specific modifier not found
                    iconClass = icons[type]['straight'] || Object.values(icons[type])[0];
                }
            }
            return `<i class="ph-bold ${iconClass}"></i>`;
        }

        function displayDirections(steps) {
            const firstStep = steps[0];
            const firstInstruction = getInstruction(firstStep);
            speak(`In ${Math.round(firstStep.distance)} meters, ${firstInstruction}`);
            dom.nextManeuverIcon.innerHTML = getManeuverIcon(firstStep.maneuver.type, firstStep.maneuver.modifier);
            dom.nextManeuverDist.textContent = `${Math.round(firstStep.distance)} m`;
            dom.nextManeuverText.textContent = firstInstruction;

            dom.directionsPanel.innerHTML = steps.map(step => {
                const dist = step.distance > 999 ? `${(step.distance / 1000).toFixed(1)} km` : `${step.distance.toFixed(0)} m`;
                const instruction = getInstruction(step);
                return `<li class="py-2 border-b border-gray-100 dark:border-gray-700 flex items-center gap-3">
                        <span class="text-2xl">${getManeuverIcon(step.maneuver.type, step.maneuver.modifier)}</span>
                        <span class="flex-grow">${instruction}</span>
                        <span class="font-semibold text-blue-500">${dist}</span></li>`;
            }).join('');
        }
        
        function endNavigation() {
            state.isNavigating = false;
            clearInterval(state.etaInterval);
            if (state.routeLayer) state.map.removeLayer(state.routeLayer);
            if (state.destinationMarker) state.map.removeLayer(state.destinationMarker);
            state.routeLayer = state.destinationMarker = state.routeData = null;
            
            dom.searchContainer.classList.remove('hidden');
            dom.navigationPanel.classList.add('hidden');
            dom.statusPanel.classList.remove('hidden');
            dom.directionsContainer.classList.add('hidden');
            dom.travelModeSelector.classList.remove('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.statusText.textContent = "Tap map or search to set destination.";
            if (state.currentLocation) state.map.setView(state.currentLocation, 16);
        }

        window.onload = initMap;
    </script>
</body>
</html>
