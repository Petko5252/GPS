<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPS Navigation</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <script src="https://unpkg.com/leaflet-geometryutil@0.10.2/src/leaflet.geometryutil.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>
    
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        .loader { border: 4px solid #f3f3f320; border-top: 4px solid #3B82F6; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #language-selector {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem;
        }
        .leaflet-control-container { z-index: 30 !important; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 overflow-hidden">
    
    <div class="w-screen h-screen flex flex-col md:flex-row">
        
        <div id="sidebar" class="order-2 md:order-1 w-full md:w-96 md:h-screen bg-gray-100 dark:bg-gray-900 flex flex-col p-4 gap-4 shadow-lg md:shadow-none z-30">
            <div id="search-container" class="w-full pointer-events-auto">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg flex flex-col">
                    <div class="flex items-center gap-2 p-3">
                        <i class="ph ph-magnifying-glass text-gray-400 text-xl"></i>
                        <input type="text" id="search-input" placeholder="Search for a destination..." class="w-full bg-transparent focus:outline-none text-gray-800 dark:text-gray-200">
                        <div id="loader" class="loader hidden"></div>
                    </div>
                    <div id="search-results" class="border-t border-gray-200 dark:border-gray-700 max-h-60 overflow-y-auto"></div>
                </div>
            </div>

            <div class="flex-grow md:hidden"></div>

            <div id="sidebar-content" class="w-full pointer-events-auto flex flex-col gap-4 md:flex-grow md:overflow-y-auto">
                <div id="selectors-container" class="bg-white dark:bg-gray-800 p-2 rounded-xl shadow-lg flex flex-col sm:flex-row gap-2">
                    <div id="travel-mode-selector" class="flex-grow bg-gray-100 dark:bg-gray-700 p-1 rounded-full flex gap-1">
                        <button data-mode="driving" class="travel-mode-btn active w-full bg-blue-500 text-white rounded-full p-2 flex justify-center items-center gap-2"><i class="ph-bold ph-car text-xl"></i><span class="hidden sm:inline">Driving</span></button>
                        <button data-mode="walking" class="travel-mode-btn w-full bg-transparent text-gray-600 dark:text-gray-300 rounded-full p-2 flex justify-center items-center gap-2"><i class="ph-bold ph-person text-xl"></i><span class="hidden sm:inline">Walking</span></button>
                        <button data-mode="cycling" class="travel-mode-btn w-full bg-transparent text-gray-600 dark:text-gray-300 rounded-full p-2 flex justify-center items-center gap-2"><i class="ph-bold ph-bicycle text-xl"></i><span class="hidden sm:inline">Cycling</span></button>
                    </div>
                    <select id="language-selector" class="bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-200 font-medium p-2 pl-3 rounded-full shadow-inner focus:outline-none">
                        <option value="en">English</option><option value="de">Deutsch</option><option value="fr">Français</option><option value="es">Español</option><option value="it">Italiano</option>
                    </select>
                </div>

                 <div id="status-panel" class="bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-4 text-center"><p id="status-text" class="text-gray-700 dark:text-gray-300 font-medium">Initializing GPS...</p></div>
                 <div id="route-summary-panel" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-4 flex flex-col gap-4">
                      <div>
                          <p class="text-2xl font-bold text-gray-800 dark:text-gray-200" id="summary-duration">-- min</p>
                          <p class="text-gray-500 dark:text-gray-400" id="summary-distance">-- km</p>
                      </div>
                      <button id="start-nav-btn" class="bg-blue-500 text-white font-bold py-3 w-full rounded-lg hover:bg-blue-600">Start</button>
                 </div>
                 <div id="directions-container" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-h-[40vh] md:max-h-full md:flex-1 flex flex-col">
                     <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between flex-shrink-0">
                        <h2 class="text-lg font-bold text-gray-800 dark:text-gray-200">Directions</h2>
                        <button id="mute-btn" title="Toggle Voice" class="text-gray-700 dark:text-gray-200 w-10 h-10 rounded-full flex items-center justify-center"><i id="mute-icon" class="ph-bold ph-speaker-high text-2xl"></i></button>
                     </div>
                     <div id="directions-panel" class="overflow-y-auto p-4 flex-grow text-gray-700 dark:text-gray-300"></div>
                     <button id="end-nav-btn" class="bg-red-500 text-white font-bold py-3 w-full rounded-b-xl hover:bg-red-600">End Navigation</button>
                 </div>
            </div>
        </div>

        <main class="order-1 md:order-2 flex-grow h-full w-full relative">
            <div id="map" class="absolute inset-0 z-10"></div>
            
            <div class="relative z-20 h-full w-full flex flex-col p-4 md:p-6 gap-4 pointer-events-none">
                <div id="navigation-panel" class="hidden w-full max-w-md mx-auto pointer-events-auto bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4">
                     <div class="flex items-center gap-4">
                         <div id="next-maneuver-icon" class="text-blue-500 text-4xl"></div>
                         <div class="flex-grow">
                             <p id="next-maneuver-dist" class="text-xl font-bold text-gray-800 dark:text-gray-200">...</p>
                             <p id="next-maneuver-text" class="text-gray-600 dark:text-gray-400">...</p>
                         </div>
                         <div id="eta-distance" class="text-right">
                             <p id="eta-text" class="text-xl font-bold text-gray-800 dark:text-gray-200">--:--</p>
                             <p id="distance-text" class="text-gray-600 dark:text-gray-400">0 km</p>
                         </div>
                     </div>
                </div>
                
                <div class="flex-grow"></div> <div class="absolute right-4 md:right-6 bottom-4 flex flex-col gap-3 pointer-events-auto">
                     <button id="recenter-btn" title="Recenter Map" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-crosshair text-2xl"></i></button>
                     <button id="dark-mode-toggle" title="Toggle Theme" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-sun text-2xl dark:hidden"></i><i class="ph-bold ph-moon text-2xl hidden dark:inline"></i></button>
                </div>
            </div>
        </main>
    </div>

    <script>
        const dom = {
            mapContainer: document.getElementById('map'), statusText: document.getElementById('status-text'),
            searchInput: document.getElementById('search-input'), searchResults: document.getElementById('search-results'),
            loader: document.getElementById('loader'), recenterBtn: document.getElementById('recenter-btn'),
            darkModeToggle: document.getElementById('dark-mode-toggle'), navigationPanel: document.getElementById('navigation-panel'),
            etaText: document.getElementById('eta-text'), distanceText: document.getElementById('distance-text'),
            statusPanel: document.getElementById('status-panel'), directionsContainer: document.getElementById('directions-container'),
            directionsPanel: document.getElementById('directions-panel'), endNavBtn: document.getElementById('end-nav-btn'),
            travelModeSelector: document.getElementById('travel-mode-selector'), searchContainer: document.getElementById('search-container'),
            routeSummaryPanel: document.getElementById('route-summary-panel'), startNavBtn: document.getElementById('start-nav-btn'),
            summaryDuration: document.getElementById('summary-duration'), summaryDistance: document.getElementById('summary-distance'),
            nextManeuverIcon: document.getElementById('next-maneuver-icon'), nextManeuverDist: document.getElementById('next-maneuver-dist'),
            nextManeuverText: document.getElementById('next-maneuver-text'), 
            muteBtn: document.getElementById('mute-btn'), muteIcon: document.getElementById('mute-icon'),
            languageSelector: document.getElementById('language-selector'),
            selectorsContainer: document.getElementById('selectors-container')
        };
        
        const state = {
            map: null, userMarker: null, routeLayer: null, destinationMarker: null, watchId: null,
            currentLocation: null, isNavigating: false, searchTimeout: null, currentTravelMode: 'driving',
            lightTileLayer: null, darkTileLayer: null, isMuted: false,
            etaInterval: null, routeData: null, routeLatLngs: [], voices: [], currentLanguage: 'en',
        };

        function initMap() {
            if (!navigator.geolocation) { dom.statusText.textContent = "Geolocation is not supported."; return; }
            loadVoices();
            if (speechSynthesis.onvoiceschanged !== undefined) { speechSynthesis.onvoiceschanged = loadVoices; }
            state.map = L.map(dom.mapContainer, { zoomControl: false }).setView([42.1354, 24.7453], 13);
            L.control.zoom({ position: 'bottomright' }).addTo(state.map);
            state.lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap' });
            state.darkTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '© OSm, © CartoDB' });
            if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark'); state.darkTileLayer.addTo(state.map);
            } else { state.lightTileLayer.addTo(state.map); }
            dom.statusText.textContent = "Acquiring your location...";
            startWatchingPosition();
            setupEventListeners();
        }

        function setupEventListeners() {
            state.map.on('click', onMapClick);
            dom.endNavBtn.addEventListener('click', endNavigation);
            dom.startNavBtn.addEventListener('click', startNavigation);
            dom.recenterBtn.addEventListener('click', () => state.currentLocation && state.map.setView([state.currentLocation.lat, state.currentLocation.lng], 16, { animate: true }));
            dom.darkModeToggle.addEventListener('click', toggleDarkMode);
            dom.muteBtn.addEventListener('click', toggleMute);
            dom.searchInput.addEventListener('input', () => { clearTimeout(state.searchTimeout); state.searchTimeout = setTimeout(performSearch, 500); });
            dom.languageSelector.addEventListener('change', (e) => {
                state.currentLanguage = e.target.value;
                if (state.destinationMarker) getRoute(state.currentLocation, state.destinationMarker.getLatLng());
            });
            dom.travelModeSelector.addEventListener('click', (e) => {
                const button = e.target.closest('.travel-mode-btn');
                if (!button || state.isNavigating || button.classList.contains('active')) return;
                state.currentTravelMode = button.dataset.mode;
                dom.travelModeSelector.querySelectorAll('.travel-mode-btn').forEach(btn => {
                    btn.classList.remove('active', 'bg-blue-500', 'text-white');
                    btn.classList.add('bg-transparent', 'text-gray-600', 'dark:text-gray-300');
                });
                button.classList.remove('bg-transparent', 'text-gray-600', 'dark:text-gray-300');
                button.classList.add('active', 'bg-blue-500', 'text-white');
                if (state.destinationMarker) getRoute(state.currentLocation, state.destinationMarker.getLatLng());
            });
        }
        
        async function getRoute(start, end) {
            dom.loader.classList.remove('hidden');
            dom.statusPanel.classList.remove('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.directionsContainer.classList.add('hidden');
            dom.statusText.textContent = "Calculating route...";

            if (!start || typeof start.lat !== 'number' || !end || typeof end.lat !== 'number') {
                dom.statusText.textContent = "Error: Invalid start or end location.";
                dom.loader.classList.add('hidden');
                return;
            }
            
            const osrmProfiles = { driving: 'car', walking: 'foot', cycling: 'bike' };
            const profile = osrmProfiles[state.currentTravelMode];
            
            // FIXED: Correct coordinate format for OSRM API
            const url = `https://router.project-osrm.org/route/v1/${profile}/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson&steps=true&language=${state.currentLanguage}`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (!response.ok || data.code !== 'Ok') {
                    throw new Error(data.message || `Server error: ${response.status}`);
                }
                if (data.routes?.length > 0) {
                    state.routeData = data.routes[0];
                    if (state.routeLayer) state.map.removeLayer(state.routeLayer);
                    const latLngs = data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    state.routeLatLngs = latLngs.map(ll => L.latLng(ll[0], ll[1]));
                    state.routeLayer = L.polyline(latLngs, { color: '#3B82F6', weight: 6, opacity: 0.8 }).addTo(state.map);
                    const paddingOptions = {};
                    if (window.innerWidth >= 768) { // Desktop
                        paddingOptions.paddingTopLeft = [384 + 24, 50]; // Sidebar width + padding, top padding
                        paddingOptions.paddingBottomRight = [50, 50];
                    } else { // Mobile
                        paddingOptions.padding = [50, 50];
                    }
                    state.map.fitBounds(state.routeLayer.getBounds(), paddingOptions);
                    showRouteSummary(state.routeData);
                } else {
                    throw new Error("No route found.");
                }
            } catch (error) { 
                console.error("Route calculation failed:", error);
                dom.statusText.textContent = `Error: ${error.message}`;
                dom.statusPanel.classList.remove('hidden');
            }
            finally { 
                dom.loader.classList.add('hidden'); 
            }
        }

        function startNavigation() {
            if (!state.routeData) return;
            state.isNavigating = true;
            dom.searchContainer.classList.add('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.navigationPanel.classList.remove('hidden');
            dom.directionsContainer.classList.remove('hidden');
            dom.selectorsContainer.classList.add('hidden');
            if (state.destinationMarker) state.destinationMarker.setPopupContent(null);
            displayDirections(state.routeData.legs[0].steps);
            updateNavDisplay(state.routeData.distance, state.routeData.duration);
            if(state.etaInterval) clearInterval(state.etaInterval);
            state.etaInterval = setInterval(() => { if(state.isNavigating) updateNavigationProgress(); }, 10000);
        }

        function endNavigation() {
            state.isNavigating = false;
            clearInterval(state.etaInterval);
            if (state.routeLayer) state.map.removeLayer(state.routeLayer);
            if (state.destinationMarker) { state.map.removeLayer(state.destinationMarker); state.destinationMarker = null; }
            state.routeData = state.routeLayer = null;
            state.routeLatLngs = [];
            dom.searchContainer.classList.remove('hidden');
            dom.navigationPanel.classList.add('hidden');
            dom.directionsContainer.classList.add('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.selectorsContainer.classList.remove('hidden');
            dom.statusPanel.classList.remove('hidden');
            dom.statusText.textContent = "Select a destination to begin.";
            if (state.currentLocation) state.map.setView([state.currentLocation.lat, state.currentLocation.lng], 16);
        }

        function loadVoices() { state.voices = speechSynthesis.getVoices(); }
        function startWatchingPosition() { const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }; state.watchId = navigator.geolocation.watchPosition(onPositionUpdate, (e) => dom.statusText.textContent = "GPS signal lost.", options); }
        function onPositionUpdate(position) { 
            const { latitude, longitude, heading } = position.coords; 
            const newLocation = { lat: latitude, lng: longitude }; 
            state.currentLocation = newLocation; 
            if (!state.userMarker) { 
                state.map.setView(newLocation, 16); 
                const userIconHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><path fill="#3B82F6" d="M232,128A104,104,0,0,1,38.26,169.87L25.47,225.1a16,16,0,0,1-20-20L60.13,192.31A104,104,0,1,1,232,128Z"></path></svg>`; 
                state.userMarker = L.marker(newLocation, { icon: L.divIcon({ className: 'user-location-icon', html: userIconHTML, iconSize: [28, 28] }) }).addTo(state.map); 
                dom.statusText.textContent = "Select a destination to begin."; 
            } else { 
                state.userMarker.setLatLng(newLocation); 
            } 
            if (heading !== null) { 
                const iconElement = state.userMarker.getElement()?.querySelector('svg'); 
                if (iconElement) iconElement.style.transform = `rotate(${heading}deg)`; 
            } 
            if (state.isNavigating) { 
                state.map.panTo(newLocation, { animate: true }); 
                updateNavigationProgress(); 
            } 
        }
        
        function updateNavigationProgress() { 
            if (!state.routeLatLngs || state.routeLatLngs.length === 0) return; 
            const userLatLng = L.latLng(state.currentLocation.lat, state.currentLocation.lng); 
            let closestPointInfo = getClosestPointOnPolyline(userLatLng, state.routeLatLngs); 
            let remainingDistance = Math.max(0, state.routeData.distance - closestPointInfo.distanceTraveled); 
            const averageSpeed = state.routeData.distance / state.routeData.duration; 
            let remainingDuration = (averageSpeed > 0) ? Math.max(0, remainingDistance / averageSpeed) : 0; 
            updateNavDisplay(remainingDistance, remainingDuration); 
        }
        
        function getClosestPointOnPolyline(point, polyline) { 
            let minDistance = Infinity; 
            let closestPoint = null; 
            let distanceTraveled = 0; 
            let totalDistanceAlongPolyline = 0; 
            for (let i = 0; i < polyline.length - 1; i++) { 
                const start = polyline[i]; 
                const end = polyline[i + 1]; 
                const segmentClosestPoint = L.GeometryUtil.closest(state.map, [start, end], point); 
                if(!segmentClosestPoint) continue; 
                const distanceToSegment = point.distanceTo(segmentClosestPoint); 
                if (distanceToSegment < minDistance) { 
                    minDistance = distanceToSegment; 
                    const traveledOnSegment = start.distanceTo(segmentClosestPoint); 
                    distanceTraveled = totalDistanceAlongPolyline + traveledOnSegment; 
                } 
                totalDistanceAlongPolyline += start.distanceTo(end); 
            } 
            return { distanceTraveled: distanceTraveled }; 
        }
        
        function updateNavDisplay(remainingDistance, remainingDuration) { 
            const eta = new Date(Date.now() + remainingDuration * 1000); 
            dom.etaText.textContent = eta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); 
            dom.distanceText.textContent = `${(remainingDistance / 1000).toFixed(1)} km`; 
        }
        
        function speak(text) { 
            if (state.isMuted || !('speechSynthesis' in window)) return; 
            window.speechSynthesis.cancel(); 
            const utterance = new SpeechSynthesisUtterance(text); 
            utterance.lang = state.currentLanguage; 
            const voice = state.voices.find(v => v.lang.startsWith(state.currentLanguage)); 
            if (voice) utterance.voice = voice; 
            window.speechSynthesis.speak(utterance); 
        }
        
        function showRouteSummary(route) { 
            dom.statusPanel.classList.add('hidden'); 
            const durationMin = Math.round(route.duration / 60); 
            const distanceKm = (route.distance / 1000).toFixed(1); 
            dom.summaryDuration.textContent = `${durationMin} min`; 
            dom.summaryDistance.textContent = `${distanceKm} km`; 
            dom.routeSummaryPanel.classList.remove('hidden'); 
        }
        
        function onMapClick(e) { 
            if (state.isNavigating) return; 
            setDestination(e.latlng); 
        }
        
        function setDestination(latlng) { 
            if (state.destinationMarker) { 
                state.destinationMarker.setLatLng(latlng); 
            } else { 
                state.destinationMarker = L.marker(latlng).addTo(state.map); 
            } 
            if (state.currentLocation) getRoute(state.currentLocation, latlng); 
            else dom.statusText.textContent = "Waiting for location to get route."; 
        }
        
        async function performSearch() { 
            const query = dom.searchInput.value; 
            if (query.length < 3) { dom.searchResults.innerHTML = ''; return; } 
            dom.loader.classList.remove('hidden'); 
            try { 
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&accept-language=${state.currentLanguage}`); 
                const data = await response.json(); 
                dom.searchResults.innerHTML = data.length === 0 ? `<div class="p-3 text-gray-500">No results found.</div>` : data.map(result => `<div class="p-3 border-b border-gray-200 dark:border-gray-700 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" data-lat="${result.lat}" data-lon="${result.lon}"><p class="font-semibold text-gray-800 dark:text-gray-200">${result.display_name.split(',')[0]}</p><p class="text-sm text-gray-500 dark:text-gray-400">${result.display_name.substring(result.display_name.indexOf(',') + 1)}</p></div>`).join(''); 
                dom.searchResults.querySelectorAll('div[data-lat]').forEach(item => item.addEventListener('click', (e) => { 
                    setDestination({ lat: parseFloat(e.currentTarget.dataset.lat), lng: parseFloat(e.currentTarget.dataset.lon) }); 
                    dom.searchInput.value = ''; 
                    dom.searchResults.innerHTML = ''; 
                })); 
            } catch (error) { 
                dom.searchResults.innerHTML = `<div class="p-3 text-red-500">Search failed.</div>`; 
            } finally { 
                dom.loader.classList.add('hidden'); 
            } 
        }
        
        function toggleDarkMode() { 
            document.documentElement.classList.toggle('dark'); 
            const isDark = document.documentElement.classList.contains('dark'); 
            localStorage.setItem('theme', isDark ? 'dark' : 'light'); 
            state.map.removeLayer(isDark ? state.lightTileLayer : state.darkTileLayer); 
            (isDark ? state.darkTileLayer : state.lightTileLayer).addTo(state.map); 
        }
        
        function toggleMute() { 
            state.isMuted = !state.isMuted; 
            dom.muteIcon.className = state.isMuted ? 'ph-bold ph-speaker-slash text-2xl' : 'ph-bold ph-speaker-high text-2xl'; 
            if (!state.isMuted) speak("Voice guidance enabled."); 
        }
        
        function getInstruction(step) { return step.maneuver.instruction; }
        
        function getManeuverIcon(type, modifier) { 
            const icons = {
                'depart': 'ph-navigation-arrow',
                'turn': {
                    'uturn': 'ph-arrow-u-up-left',
                    'sharp right': 'ph-arrow-elbow-right',
                    'right': 'ph-arrow-bend-up-right',
                    'slight right': 'ph-arrow-bend-up-right',
                    'straight': 'ph-arrow-up',
                    'slight left': 'ph-arrow-bend-up-left',
                    'left': 'ph-arrow-bend-up-left',
                    'sharp left': 'ph-arrow-elbow-left',
                },
                'fork': {
                    'right': 'ph-git-fork',
                    'left': 'ph-git-fork',
                    'straight': 'ph-arrow-up'
                },
                'end of road': 'ph-sign-t',
                'use lane': 'ph-arrow-line-up',
                'merge': 'ph-arrows-merge',
                'ramp': 'ph-arrow-up-right',
                'roundabout': 'ph-radio-button',
                'rotary': 'ph-radio-button',
                'continue': 'ph-arrow-up',
                'arrive': 'ph-check-circle',
                'new name': 'ph-arrow-up',
                'default': 'ph-question'
            }; 
            let iconClass = icons.default; 
            if (icons[type]) { 
                if (typeof icons[type] === 'string') iconClass = icons[type]; 
                else if (typeof icons[type] === 'object' && icons[type][modifier]) iconClass = icons[type][modifier]; 
                else if (typeof icons[type] === 'object') iconClass = icons[type]['straight'] || Object.values(icons[type])[0]; 
            } 
            return `<i class="ph-bold ${iconClass}"></i>`; 
        }
        
        function displayDirections(steps) { 
            const firstStep = steps[0]; 
            const firstInstruction = getInstruction(firstStep); 
            speak(`In ${Math.round(firstStep.distance)} meters, ${firstInstruction}`); 
            dom.nextManeuverIcon.innerHTML = getManeuverIcon(firstStep.maneuver.type, firstStep.maneuver.modifier); 
            dom.nextManeuverDist.textContent = `${Math.round(firstStep.distance)} m`; 
            dom.nextManeuverText.textContent = firstInstruction; 
            dom.directionsPanel.innerHTML = steps.map(step => { 
                const dist = step.distance > 999 ? `${(step.distance / 1000).toFixed(1)} km` : `${step.distance.toFixed(0)} m`; 
                return `<li class="py-2 border-b border-gray-100 dark:border-gray-700 flex items-center gap-3"><span class="text-2xl">${getManeuverIcon(step.maneuver.type, step.maneuver.modifier)}</span><span class="flex-grow">${getInstruction(step)}</span><span class="font-semibold text-blue-500">${dist}</span></li>`; 
            }).join(''); 
        }
        
        window.onload = initMap;
    </script>
</body>
</html>
