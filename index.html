<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPS Navigation</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>
    
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 10; }
        .user-location-icon svg { filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4)); transition: transform 0.3s ease-out; }
        .loader { border: 4px solid #f3f3f320; border-top: 4px solid #3B82F6; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #traffic-btn.active { background-color: #3B82F6; color: white; }
        /* Custom style for the language selector */
        #language-selector {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 overflow-hidden">

    <div id="map"></div>

    <div class="relative z-20 h-screen w-screen flex flex-col p-4 md:p-6 gap-4 pointer-events-none">
        
        <div id="search-container" class="w-full max-w-md mx-auto pointer-events-auto">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg flex flex-col">
                <div class="flex items-center gap-2 p-3">
                    <i class="ph ph-magnifying-glass text-gray-400 text-xl"></i>
                    <input type="text" id="search-input" placeholder="Search for a destination..." class="w-full bg-transparent focus:outline-none text-gray-800 dark:text-gray-200">
                    <div id="loader" class="loader hidden"></div>
                </div>
                <div id="search-results" class="border-t border-gray-200 dark:border-gray-700 max-h-60 overflow-y-auto"></div>
            </div>
        </div>
        
        <div id="navigation-panel" class="hidden w-full max-w-md mx-auto pointer-events-auto bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4">
             <div class="flex items-center gap-4">
                 <div id="next-maneuver-icon" class="text-blue-500 text-4xl"></div>
                 <div class="flex-grow">
                     <p id="next-maneuver-dist" class="text-xl font-bold text-gray-800 dark:text-gray-200">...</p>
                     <p id="next-maneuver-text" class="text-gray-600 dark:text-gray-400">...</p>
                 </div>
                 <div id="eta-distance" class="text-right">
                     <p id="eta-text" class="text-xl font-bold text-gray-800 dark:text-gray-200">--:--</p>
                     <p id="distance-text" class="text-gray-600 dark:text-gray-400">0 km</p>
                 </div>
             </div>
        </div>
        
        <div class="flex-grow"></div> <div class="absolute right-4 md:right-6 bottom-36 flex flex-col gap-3 pointer-events-auto">
             <button id="recenter-btn" title="Recenter Map" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-crosshair text-2xl"></i></button>
             <button id="traffic-btn" title="Toggle Traffic" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-traffic-signal text-2xl"></i></button>
             <button id="mute-btn" title="Toggle Voice" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i id="mute-icon" class="ph-bold ph-speaker-high text-2xl"></i></button>
             <button id="dark-mode-toggle" title="Toggle Theme" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-sun text-2xl dark:hidden"></i><i class="ph-bold ph-moon text-2xl hidden dark:inline"></i></button>
        </div>

        <div class="flex flex-col items-center pointer-events-auto">
             <div class="flex items-center gap-2 mb-4">
                <select id="language-selector" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 font-medium py-2 pl-3 pr-10 rounded-full shadow-lg focus:outline-none">
                    <option value="en">English</option>
                    <option value="de">Deutsch</option>
                    <option value="fr">Français</option>
                    <option value="es">Español</option>
                    <option value="it">Italiano</option>
                </select>
                <div id="travel-mode-selector" class="bg-white dark:bg-gray-800 p-2 rounded-full shadow-lg flex gap-2">
                    <button data-mode="driving" class="travel-mode-btn active bg-blue-500 text-white rounded-full px-4 py-2 flex items-center gap-2"><i class="ph-bold ph-car"></i></button>
                    <button data-mode="walking" class="travel-mode-btn bg-transparent text-gray-600 dark:text-gray-300 rounded-full px-4 py-2 flex items-center gap-2"><i class="ph-bold ph-person"></i></button>
                    <button data-mode="cycling" class="travel-mode-btn bg-transparent text-gray-600 dark:text-gray-300 rounded-full px-4 py-2 flex items-center gap-2"><i class="ph-bold ph-bicycle"></i></button>
                </div>
            </div>
            
            <div id="bottom-panel" class="w-full max-w-2xl mx-auto">
                 <div id="status-panel" class="bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-4 text-center"><p id="status-text" class="text-gray-700 dark:text-gray-300 font-medium">Initializing GPS...</p></div>
                 <div id="route-summary-panel" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-4 flex flex-col gap-4">
                      <div>
                          <p class="text-2xl font-bold text-gray-800 dark:text-gray-200" id="summary-duration">-- min</p>
                          <p class="text-gray-500 dark:text-gray-400" id="summary-distance">-- km</p>
                      </div>
                      <button id="start-nav-btn" class="bg-blue-500 text-white font-bold py-3 w-full rounded-lg hover:bg-blue-600">Start</button>
                 </div>
                 <div id="directions-container" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-h-[40vh] flex flex-col">
                     <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0"><h2 class="text-lg font-bold text-gray-800 dark:text-gray-200">Directions</h2></div>
                     <div id="directions-panel" class="overflow-y-auto p-4 flex-grow text-gray-700 dark:text-gray-300"></div>
                     <button id="end-nav-btn" class="bg-red-500 text-white font-bold py-3 w-full rounded-b-xl hover:bg-red-600">End Navigation</button>
                 </div>
            </div>
        </div>
    </div>

    <script>
        const dom = {
            mapContainer: document.getElementById('map'), statusText: document.getElementById('status-text'),
            searchInput: document.getElementById('search-input'), searchResults: document.getElementById('search-results'),
            loader: document.getElementById('loader'), recenterBtn: document.getElementById('recenter-btn'),
            darkModeToggle: document.getElementById('dark-mode-toggle'), navigationPanel: document.getElementById('navigation-panel'),
            etaText: document.getElementById('eta-text'), distanceText: document.getElementById('distance-text'),
            statusPanel: document.getElementById('status-panel'), directionsContainer: document.getElementById('directions-container'),
            directionsPanel: document.getElementById('directions-panel'), endNavBtn: document.getElementById('end-nav-btn'),
            travelModeSelector: document.getElementById('travel-mode-selector'), searchContainer: document.getElementById('search-container'),
            routeSummaryPanel: document.getElementById('route-summary-panel'), startNavBtn: document.getElementById('start-nav-btn'),
            summaryDuration: document.getElementById('summary-duration'), summaryDistance: document.getElementById('summary-distance'),
            nextManeuverIcon: document.getElementById('next-maneuver-icon'), nextManeuverDist: document.getElementById('next-maneuver-dist'),
            nextManeuverText: document.getElementById('next-maneuver-text'), trafficBtn: document.getElementById('traffic-btn'),
            muteBtn: document.getElementById('mute-btn'), muteIcon: document.getElementById('mute-icon'),
            languageSelector: document.getElementById('language-selector'),
        };

        const state = {
            map: null, userMarker: null, routeLayer: null, destinationMarker: null, watchId: null,
            currentLocation: null, isNavigating: false, searchTimeout: null, currentTravelMode: 'driving',
            lightTileLayer: null, darkTileLayer: null, trafficLayer: null, isMuted: false,
            etaInterval: null, routeData: null, routeLatLngs: [], voices: [], currentLanguage: 'en',
        };

        function initMap() {
            if (!navigator.geolocation) {
                dom.statusText.textContent = "Geolocation is not supported."; return;
            }
            // Load speech synthesis voices
            loadVoices();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoices;
            }

            state.map = L.map(dom.mapContainer, { zoomControl: false }).setView([42.1354, 24.7453], 13); // Centered on Plovdiv
            L.control.zoom({ position: 'bottomright' }).addTo(state.map);

            state.lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap' });
            state.darkTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '© OSm, © CartoDB' });
            
            state.trafficLayer = L.tileLayer('');
            
            if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark'); state.darkTileLayer.addTo(state.map);
            } else { state.lightTileLayer.addTo(state.map); }
            
            dom.statusText.textContent = "Acquiring your location...";
            startWatchingPosition();
            setupEventListeners();
        }

        function loadVoices() {
            state.voices = speechSynthesis.getVoices();
        }

        function setupEventListeners() {
            // ... (keep all existing event listeners)
            state.map.on('click', onMapClick);
            dom.endNavBtn.addEventListener('click', endNavigation);
            dom.startNavBtn.addEventListener('click', startNavigation);
            dom.recenterBtn.addEventListener('click', () => state.currentLocation && state.map.setView([state.currentLocation.lat, state.currentLocation.lng], 16, { animate: true }));
            dom.darkModeToggle.addEventListener('click', toggleDarkMode);
            dom.trafficBtn.addEventListener('click', toggleTraffic);
            dom.muteBtn.addEventListener('click', toggleMute);
            dom.searchInput.addEventListener('input', () => { clearTimeout(state.searchTimeout); state.searchTimeout = setTimeout(performSearch, 500); });

            // Language selector
            dom.languageSelector.addEventListener('change', (e) => {
                state.currentLanguage = e.target.value;
                if (state.destinationMarker) {
                    getRoute(state.currentLocation, state.destinationMarker.getLatLng());
                }
            });

            // Travel mode selector
            dom.travelModeSelector.addEventListener('click', (e) => {
                const button = e.target.closest('.travel-mode-btn');
                if (!button || state.isNavigating || button.classList.contains('active')) return;

                state.currentTravelMode = button.dataset.mode;
                
                document.querySelectorAll('.travel-mode-btn').forEach(btn => {
                    btn.classList.remove('active', 'bg-blue-500', 'text-white');
                    btn.classList.add('bg-transparent', 'text-gray-600', 'dark:text-gray-300');
                });
                
                button.classList.remove('bg-transparent', 'text-gray-600', 'dark:text-gray-300');
                button.classList.add('active', 'bg-blue-500', 'text-white');
                
                if (state.destinationMarker) {
                    getRoute(state.currentLocation, state.destinationMarker.getLatLng());
                }
            });
        }
        
        function startWatchingPosition() {
            const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };
            state.watchId = navigator.geolocation.watchPosition(onPositionUpdate, (e) => {
                dom.statusText.textContent = "GPS signal lost. Please enable location services.";
                console.error("Geolocation error:", e.message);
            }, options);
        }

        function onPositionUpdate(position) {
            const { latitude, longitude, heading } = position.coords;
            const newLocation = { lat: latitude, lng: longitude };
            state.currentLocation = newLocation;

            if (!state.userMarker) {
                state.map.setView(newLocation, 16);
                const userIconHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><path fill="#3B82F6" d="M232,128A104,104,0,0,1,38.26,169.87L25.47,225.1a16,16,0,0,1-20-20L60.13,192.31A104,104,0,1,1,232,128Z"></path></svg>`;
                state.userMarker = L.marker(newLocation, { icon: L.divIcon({ className: 'user-location-icon', html: userIconHTML, iconSize: [28, 28] }) }).addTo(state.map);
                dom.statusText.textContent = "Select a destination to begin.";
            } else {
                state.userMarker.setLatLng(newLocation);
            }

            if (heading !== null) {
                const iconElement = state.userMarker.getElement()?.querySelector('svg');
                if (iconElement) iconElement.style.transform = `rotate(${heading}deg)`;
            }

            if (state.isNavigating) {
                state.map.panTo(newLocation, { animate: true });
                updateNavigationProgress();
            }
        }

        // --- NEW: Function to update navigation progress based on real location ---
        function updateNavigationProgress() {
            if (!state.routeLatLngs || state.routeLatLngs.length === 0) return;

            const userLatLng = L.latLng(state.currentLocation.lat, state.currentLocation.lng);
            let closestPointInfo = getClosestPointOnPolyline(userLatLng, state.routeLatLngs);
            
            // Calculate remaining distance
            let remainingDistance = state.routeData.distance - closestPointInfo.distanceTraveled;
            if (remainingDistance < 0) remainingDistance = 0;

            // Estimate remaining duration
            const averageSpeed = state.routeData.distance / state.routeData.duration; // meters per second
            let remainingDuration = remainingDistance / averageSpeed; // in seconds
            if (remainingDuration < 0) remainingDuration = 0;
            
            updateNavDisplay(remainingDistance, remainingDuration);
        }

        // --- NEW: Helper function to find the closest point on the route ---
        function getClosestPointOnPolyline(point, polyline) {
            let minDistance = Infinity;
            let closestPoint = null;
            let distanceTraveled = 0;
            let totalDistanceAlongPolyline = 0;

            for (let i = 0; i < polyline.length - 1; i++) {
                const start = polyline[i];
                const end = polyline[i + 1];
                const segmentDistance = start.distanceTo(end);
                
                const segmentClosestPoint = L.GeometryUtil.closest(state.map, [start, end], point);
                const distanceToSegment = point.distanceTo(segmentClosestPoint);

                if (distanceToSegment < minDistance) {
                    minDistance = distanceToSegment;
                    closestPoint = segmentClosestPoint;
                    const traveledOnSegment = start.distanceTo(segmentClosestPoint);
                    distanceTraveled = totalDistanceAlongPolyline + traveledOnSegment;
                }
                totalDistanceAlongPolyline += segmentDistance;
            }
            return { point: closestPoint, distanceTraveled: distanceTraveled };
        }
        
        // --- REFACTORED: `updateNavDisplay` now just renders data ---
        function updateNavDisplay(remainingDistance, remainingDuration) {
            // Update ETA
            const eta = new Date(Date.now() + remainingDuration * 1000);
            dom.etaText.textContent = eta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            // Update remaining distance
            dom.distanceText.textContent = `${(remainingDistance / 1000).toFixed(1)} km`;
        }
        
        function speak(text) {
            if (state.isMuted || !('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = state.currentLanguage;

            // Find a matching voice
            const voice = state.voices.find(v => v.lang.startsWith(state.currentLanguage));
            if (voice) {
                utterance.voice = voice;
            } else {
                console.warn(`No voice found for language: ${state.currentLanguage}`);
            }

            window.speechSynthesis.speak(utterance);
        }

        async function getRoute(start, end) {
            dom.loader.classList.remove('hidden');
            dom.statusText.textContent = "Calculating route...";
            dom.statusPanel.classList.remove('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            
            const osrmProfiles = { driving: 'car', walking: 'foot', cycling: 'bike' };
            const profile = osrmProfiles[state.currentTravelMode] || 'car';
            
            // --- UPDATED: Added language parameter to API call ---
            const url = `https://router.project-osrm.org/route/v1/${profile}/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson&steps=true&language=${state.currentLanguage}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(await response.text());

                const data = await response.json();
                
                if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                    state.routeData = data.routes[0];
                    if (state.routeLayer) state.map.removeLayer(state.routeLayer);
                    
                    const latLngs = data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    state.routeLatLngs = latLngs.map(ll => L.latLng(ll[0], ll[1])); // Store for calculations
                    
                    state.routeLayer = L.polyline(latLngs, { color: '#3B82F6', weight: 6, opacity: 0.8 }).addTo(state.map);
                    state.map.fitBounds(state.routeLayer.getBounds(), { padding: [100, 100] });
                    showRouteSummary(state.routeData);
                } else { 
                    dom.statusText.textContent = data.message || "Could not find a route.";
                }
            } catch (error) { 
                console.error("Error fetching route:", error);
                dom.statusText.textContent = "Error calculating route."; 
            }
            finally { 
                dom.loader.classList.add('hidden'); 
            }
        }
        
        function startNavigation() {
            if (!state.routeData) return;
            state.isNavigating = true;
            dom.searchContainer.classList.add('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.navigationPanel.classList.remove('hidden');
            dom.directionsContainer.classList.remove('hidden');
            dom.travelModeSelector.parentElement.classList.add('hidden');
            if (state.destinationMarker) state.destinationMarker.closePopup();

            displayDirections(state.routeData.legs[0].steps);
            
            // Initial nav display update
            updateNavDisplay(state.routeData.distance, state.routeData.duration);
            // Set an interval just to keep the ETA clock ticking every 30 seconds
            if(state.etaInterval) clearInterval(state.etaInterval);
            state.etaInterval = setInterval(() => {
                if(state.isNavigating) updateNavigationProgress();
            }, 30000);
        }
        
        function endNavigation() {
            state.isNavigating = false;
            clearInterval(state.etaInterval);
            if (state.routeLayer) state.map.removeLayer(state.routeLayer);
            if (state.destinationMarker) state.map.removeLayer(state.destinationMarker);
            state.routeLayer = state.destinationMarker = state.routeData = null;
            state.routeLatLngs = [];
            
            dom.searchContainer.classList.remove('hidden');
            dom.navigationPanel.classList.add('hidden');
            dom.statusPanel.classList.remove('hidden');
            dom.directionsContainer.classList.add('hidden');
            dom.travelModeSelector.parentElement.classList.remove('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.statusText.textContent = "Select a destination to begin.";
            if (state.currentLocation) state.map.setView([state.currentLocation.lat, state.currentLocation.lng], 16);
        }

        // --- Keep all other utility functions like getInstruction, getManeuverIcon, displayDirections, etc. ---
        // (No changes needed for the functions below, they are included for completeness)
        
        function showRouteSummary(route) {
            const durationMin = Math.round(route.duration / 60);
            const distanceKm = (route.distance / 1000).toFixed(1);
            dom.summaryDuration.textContent = `${durationMin} min`;
            dom.summaryDistance.textContent = `${distanceKm} km`;
            dom.statusPanel.classList.add('hidden');
            dom.routeSummaryPanel.classList.remove('hidden');
        }

        function onMapClick(e) { if (state.isNavigating) return; setDestination(e.latlng); }

        function setDestination(latlng) {
            if (state.destinationMarker) { state.destinationMarker.setLatLng(latlng); } 
            else { state.destinationMarker = L.marker(latlng).addTo(state.map).bindPopup("Destination").openPopup(); }
            if (state.currentLocation) getRoute(state.currentLocation, latlng);
            else dom.statusText.textContent = "Waiting for location to get route.";
        }

        async function performSearch() {
            const query = dom.searchInput.value;
            if (query.length < 3) { dom.searchResults.innerHTML = ''; return; }
            dom.loader.classList.remove('hidden');
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&accept-language=${state.currentLanguage}`);
                const data = await response.json();
                dom.searchResults.innerHTML = data.length === 0 ? `<div class="p-3 text-gray-500">No results found.</div>` : data.map(result => `
                    <div class="p-3 border-b border-gray-200 dark:border-gray-700 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" data-lat="${result.lat}" data-lon="${result.lon}">
                        <p class="font-semibold text-gray-800 dark:text-gray-200">${result.display_name.split(',')[0]}</p>
                        <p class="text-sm text-gray-500 dark:text-gray-400">${result.display_name.substring(result.display_name.indexOf(',') + 1)}</p>
                    </div>`).join('');
                dom.searchResults.querySelectorAll('div[data-lat]').forEach(item => item.addEventListener('click', (e) => {
                    setDestination({ lat: e.currentTarget.dataset.lat, lng: e.currentTarget.dataset.lon });
                    dom.searchInput.value = ''; dom.searchResults.innerHTML = '';
                }));
            } catch (error) { dom.searchResults.innerHTML = `<div class="p-3 text-red-500">Search failed.</div>`; } 
            finally { dom.loader.classList.add('hidden'); }
        }

        function toggleDarkMode() {
            document.documentElement.classList.toggle('dark');
            const isDark = document.documentElement.classList.contains('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            state.map.removeLayer(isDark ? state.lightTileLayer : state.darkTileLayer);
            (isDark ? state.darkTileLayer : state.lightTileLayer).addTo(state.map);
        }
        
        function toggleTraffic() {
            alert("Traffic layer is not configured. A valid TileLayer URL and API key are required.");
        }
        
        function toggleMute() {
            state.isMuted = !state.isMuted;
            dom.muteIcon.className = state.isMuted ? 'ph-bold ph-speaker-slash text-2xl' : 'ph-bold ph-speaker-high text-2xl';
            if (!state.isMuted) speak("Voice guidance enabled.");
        }

        function getInstruction(step) {
            return step.maneuver.instruction;
        }

        function getManeuverIcon(type, modifier) {
            const icons = {
                'depart': 'ph-navigation-arrow', 'turn': {'uturn': 'ph-arrow-u-up-left','sharp right': 'ph-arrow-elbow-right','right': 'ph-arrow-bend-up-right','slight right': 'ph-arrow-bend-up-right','straight': 'ph-arrow-up','slight left': 'ph-arrow-bend-up-left','left': 'ph-arrow-bend-up-left','sharp left': 'ph-arrow-elbow-left',},'fork': {'right': 'ph-git-fork','left': 'ph-git-fork','straight': 'ph-arrow-up'},'end of road': 'ph-sign-t','use lane': 'ph-arrow-line-up','merge': 'ph-arrows-merge','ramp': 'ph-arrow-up-right','roundabout': 'ph-radio-button','rotary': 'ph-radio-button','continue': 'ph-arrow-up','arrive': 'ph-check-circle','new name': 'ph-arrow-up','default': 'ph-question'
            };
            let iconClass = icons.default;
            if (icons[type]) {
                if (typeof icons[type] === 'string') iconClass = icons[type];
                else if (typeof icons[type] === 'object' && icons[type][modifier]) iconClass = icons[type][modifier];
                else if (typeof icons[type] === 'object') iconClass = icons[type]['straight'] || Object.values(icons[type])[0];
            }
            return `<i class="ph-bold ${iconClass}"></i>`;
        }

        function displayDirections(steps) {
            const firstStep = steps[0];
            const firstInstruction = getInstruction(firstStep);
            speak(`In ${Math.round(firstStep.distance)} meters, ${firstInstruction}`);
            dom.nextManeuverIcon.innerHTML = getManeuverIcon(firstStep.maneuver.type, firstStep.maneuver.modifier);
            dom.nextManeuverDist.textContent = `${Math.round(firstStep.distance)} m`;
            dom.nextManeuverText.textContent = firstInstruction;

            dom.directionsPanel.innerHTML = steps.map(step => {
                const dist = step.distance > 999 ? `${(step.distance / 1000).toFixed(1)} km` : `${step.distance.toFixed(0)} m`;
                return `<li class="py-2 border-b border-gray-100 dark:border-gray-700 flex items-center gap-3">
                        <span class="text-2xl">${getManeuverIcon(step.maneuver.type, step.maneuver.modifier)}</span>
                        <span class="flex-grow">${getInstruction(step)}</span>
                        <span class="font-semibold text-blue-500">${dist}</span></li>`;
            }).join('');
        }

        window.onload = initMap;
    </script>
</body>
</html>
