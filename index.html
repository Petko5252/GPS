<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>GPS Navigation</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

    <script src="https://unpkg.com/leaflet-geometryutil@0.10.2/src/leaflet.geometryutil.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>

    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />

    <style>
        body { font-family: 'Inter', sans-serif; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        .loader { border: 4px solid #f3f3f320; border-top: 4px solid #3B82F6; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #language-selector {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem;
        }
        .leaflet-control-container { z-index: 30 !important; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 overflow-hidden">

    <div class="w-screen h-screen flex flex-col md:flex-row">

        <div id="sidebar" class="order-2 md:order-1 w-full md:w-96 md:h-screen bg-gray-100 dark:bg-gray-900 flex flex-col p-4 gap-4 shadow-lg md:shadow-none z-30">
            <div id="search-container" class="w-full pointer-events-auto">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg flex flex-col">
                    <div class="flex items-center gap-2 p-3">
                        <i class="ph ph-magnifying-glass text-gray-400 text-xl"></i>
                        <input type="text" id="search-input" placeholder="Search for a destination..." class="w-full bg-transparent focus:outline-none text-gray-800 dark:text-gray-200" />
                        <div id="loader" class="loader hidden"></div>
                    </div>
                    <div id="search-results" class="border-t border-gray-200 dark:border-gray-700 max-h-60 overflow-y-auto"></div>
                </div>
            </div>

            <div class="flex-grow md:hidden"></div>

            <div id="sidebar-content" class="w-full pointer-events-auto flex flex-col gap-4 md:flex-grow md:overflow-y-auto">
                <div id="selectors-container" class="bg-white dark:bg-gray-800 p-2 rounded-xl shadow-lg flex flex-col sm:flex-row gap-2">
                    <div id="travel-mode-selector" class="flex-grow bg-gray-100 dark:bg-gray-700 p-1 rounded-full flex gap-1">
                        <button data-mode="driving" class="travel-mode-btn active w-full bg-blue-500 text-white rounded-full p-2 flex justify-center items-center gap-2"><i class="ph-bold ph-car text-xl"></i><span class="hidden sm:inline">Driving</span></button>
                        <button data-mode="walking" class="travel-mode-btn w-full bg-transparent text-gray-600 dark:text-gray-300 rounded-full p-2 flex justify-center items-center gap-2"><i class="ph-bold ph-person text-xl"></i><span class="hidden sm:inline">Walking</span></button>
                        <button data-mode="cycling" class="travel-mode-btn w-full bg-transparent text-gray-600 dark:text-gray-300 rounded-full p-2 flex justify-center items-center gap-2"><i class="ph-bold ph-bicycle text-xl"></i><span class="hidden sm:inline">Cycling</span></button>
                    </div>
                    <select id="language-selector" class="bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-200 font-medium p-2 pl-3 rounded-full shadow-inner focus:outline-none">
                        <option value="en">English</option><option value="de">Deutsch</option><option value="fr">Français</option><option value="es">Español</option><option value="it">Italiano</option>
                    </select>
                </div>

                 <div id="status-panel" class="bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-4 text-center"><p id="status-text" class="text-gray-700 dark:text-gray-300 font-medium">Initializing GPS...</p></div>
                 <div id="route-summary-panel" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-4 flex flex-col gap-4">
                      <div>
                          <p class="text-2xl font-bold text-gray-800 dark:text-gray-200" id="summary-duration">-- min</p>
                          <p class="text-gray-500 dark:text-gray-400" id="summary-distance">-- km</p>
                      </div>
                      <button id="start-nav-btn" class="bg-blue-500 text-white font-bold py-3 w-full rounded-lg hover:bg-blue-600">Start</button>
                 </div>
                 <div id="directions-container" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-h-[40vh] md:max-h-full md:flex-1 flex flex-col">
                     <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between flex-shrink-0">
                        <h2 class="text-lg font-bold text-gray-800 dark:text-gray-200">Directions</h2>
                        <button id="mute-btn" title="Toggle Voice" class="text-gray-700 dark:text-gray-200 w-10 h-10 rounded-full flex items-center justify-center"><i id="mute-icon" class="ph-bold ph-speaker-high text-2xl"></i></button>
                     </div>
                     <div id="directions-panel" class="overflow-y-auto p-4 flex-grow text-gray-700 dark:text-gray-300"></div>
                     <button id="end-nav-btn" class="bg-red-500 text-white font-bold py-3 w-full rounded-b-xl hover:bg-red-600">End Navigation</button>
                 </div>
            </div>
        </div>

        <main class="order-1 md:order-2 flex-grow h-full w-full relative">
            <div id="map" class="absolute inset-0 z-10"></div>

            <div class="relative z-20 h-full w-full flex flex-col p-4 md:p-6 gap-4 pointer-events-none">
                <div id="navigation-panel" class="hidden w-full max-w-md mx-auto pointer-events-auto bg-white dark:bg-gray-800 rounded-xl shadow-lg p-4">
                     <div class="flex items-center gap-4">
                         <div id="next-maneuver-icon" class="text-blue-500 text-4xl"></div>
                         <div class="flex-grow">
                             <p id="next-maneuver-dist" class="text-xl font-bold text-gray-800 dark:text-gray-200">...</p>
                             <p id="next-maneuver-text" class="text-gray-600 dark:text-gray-400">...</p>
                         </div>
                         <div id="eta-distance" class="text-right">
                             <p id="eta-text" class="text-xl font-bold text-gray-800 dark:text-gray-200">--:--</p>
                             <p id="distance-text" class="text-gray-600 dark:text-gray-400">0 km</p>
                         </div>
                     </div>
                </div>

                <div class="flex-grow"></div> <div class="absolute right-4 md:right-6 bottom-4 flex flex-col gap-3 pointer-events-auto">
                     <button id="recenter-btn" title="Recenter Map" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-crosshair text-2xl"></i></button>
                     <button id="dark-mode-toggle" title="Toggle Theme" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 w-12 h-12 rounded-full shadow-lg flex items-center justify-center"><i class="ph-bold ph-sun text-2xl dark:hidden"></i><i class="ph-bold ph-moon text-2xl hidden dark:inline"></i></button>
                </div>
            </div>
        </main>
    </div>

    <script>
        const dom = {
            mapContainer: document.getElementById('map'), statusText: document.getElementById('status-text'),
            searchInput: document.getElementById('search-input'), searchResults: document.getElementById('search-results'),
            loader: document.getElementById('loader'), recenterBtn: document.getElementById('recenter-btn'),
            darkModeToggle: document.getElementById('dark-mode-toggle'), navigationPanel: document.getElementById('navigation-panel'),
            etaText: document.getElementById('eta-text'), distanceText: document.getElementById('distance-text'),
            statusPanel: document.getElementById('status-panel'), directionsContainer: document.getElementById('directions-container'),
            directionsPanel: document.getElementById('directions-panel'), endNavBtn: document.getElementById('end-nav-btn'),
            travelModeSelector: document.getElementById('travel-mode-selector'), searchContainer: document.getElementById('search-container'),
            routeSummaryPanel: document.getElementById('route-summary-panel'), startNavBtn: document.getElementById('start-nav-btn'),
            summaryDuration: document.getElementById('summary-duration'), summaryDistance: document.getElementById('summary-distance'),
            nextManeuverIcon: document.getElementById('next-maneuver-icon'), nextManeuverDist: document.getElementById('next-maneuver-dist'),
            nextManeuverText: document.getElementById('next-maneuver-text'),
            muteBtn: document.getElementById('mute-btn'), muteIcon: document.getElementById('mute-icon'),
            languageSelector: document.getElementById('language-selector'),
            selectorsContainer: document.getElementById('selectors-container'),
        };

        const state = {
            map: null, userMarker: null, routeLayer: null, destinationMarker: null, watchId: null,
            currentLocation: null, isNavigating: false, searchTimeout: null, currentTravelMode: 'driving',
            lightTileLayer: null, darkTileLayer: null, isMuted: false,
            etaInterval: null, routeData: null, routeLatLngs: [], voices: [], currentLanguage: 'en',
        };

        function initMap() {
            if (!navigator.geolocation) { dom.statusText.textContent = "Geolocation is not supported."; return; }
            loadVoices();
            if (speechSynthesis.onvoiceschanged !== undefined) { speechSynthesis.onvoiceschanged = loadVoices; }
            state.map = L.map(dom.mapContainer, { zoomControl: false }).setView([42.1354, 24.7453], 13);
            L.control.zoom({ position: 'bottomright' }).addTo(state.map);
            state.lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap' });
            state.darkTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '© OSm, © CartoDB' });
            if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark'); state.darkTileLayer.addTo(state.map);
            } else { state.lightTileLayer.addTo(state.map); }
            dom.statusText.textContent = "Acquiring your location...";
            startWatchingPosition();
            setupEventListeners();
        }

        function setupEventListeners() {
            state.map.on && state.map.on('click', onMapClick);
            dom.endNavBtn.addEventListener('click', endNavigation);
            dom.startNavBtn.addEventListener('click', startNavigation);
            dom.recenterBtn.addEventListener('click', () => state.currentLocation && state.map.setView([state.currentLocation.lat, state.currentLocation.lng], 16, { animate: true }));
            dom.darkModeToggle.addEventListener('click', toggleDarkMode);
            dom.muteBtn.addEventListener('click', toggleMute);
            dom.searchInput.addEventListener('input', () => { clearTimeout(state.searchTimeout); state.searchTimeout = setTimeout(performSearch, 500); });
            dom.languageSelector.addEventListener('change', (e) => {
                state.currentLanguage = e.target.value;
                if (state.destinationMarker && state.currentLocation) getRoute(state.currentLocation, state.destinationMarker.getLatLng());
            });
            dom.travelModeSelector.addEventListener('click', (e) => {
                const button = e.target.closest && e.target.closest('.travel-mode-btn');
                if (!button || state.isNavigating || button.classList.contains('active')) return;
                state.currentTravelMode = button.dataset.mode;
                dom.travelModeSelector.querySelectorAll('.travel-mode-btn').forEach(btn => {
                    btn.classList.remove('active', 'bg-blue-500', 'text-white');
                    btn.classList.add('bg-transparent', 'text-gray-600', 'dark:text-gray-300');
                });
                button.classList.remove('bg-transparent', 'text-gray-600', 'dark:text-gray-300');
                button.classList.add('active', 'bg-blue-500', 'text-white');
                if (state.destinationMarker && state.currentLocation) getRoute(state.currentLocation, state.destinationMarker.getLatLng());
            });
        }

        async function getRoute(start, end) {
            dom.loader.classList.remove('hidden');
            dom.statusPanel.classList.remove('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.directionsContainer.classList.add('hidden');
            dom.statusText.textContent = "Calculating route...";

            if (!start || typeof start.lat !== 'number' || !end || typeof end.lat !== 'number') {
                dom.statusText.textContent = "Error: Invalid start or end location.";
                dom.loader.classList.add('hidden');
                return;
            }

            const osrmProfiles = { driving: 'car', walking: 'foot', cycling: 'bike' };
            const profile = osrmProfiles[state.currentTravelMode] || 'car';

            const url = `https://router.project-osrm.org/route/v1/${profile}/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson&steps=true`;

            try {
                const response = await fetch(url);
                const data = await response.json();
                if (!response.ok || data.code !== 'Ok') {
                    throw new Error((data && data.message) ? data.message : `Server error: ${response.status}`);
                }
                if (data.routes?.length > 0) {
                    state.routeData = data.routes[0];
                    if (state.routeLayer) { try { state.map.removeLayer(state.routeLayer); } catch(e){} }
                    // format coordinates -> [lat, lng]
                    const latLngs = data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    state.routeLatLngs = latLngs.map(ll => L.latLng(ll[0], ll[1]));
                    state.routeLayer = L.polyline(latLngs, { color: '#3B82F6', weight: 6, opacity: 0.8 }).addTo(state.map);

                    const paddingOptions = {};
                    if (window.innerWidth >= 768) {
                        paddingOptions.paddingTopLeft = [384 + 24, 50];
                        paddingOptions.paddingBottomRight = [50, 50];
                    } else {
                        paddingOptions.padding = [50, 50];
                    }
                    state.map.fitBounds(state.routeLayer.getBounds(), paddingOptions);
                    showRouteSummary(state.routeData);
                } else {
                    throw new Error("No route found.");
                }
            } catch (error) {
                console.error("Route calculation failed:", error);
                dom.statusText.textContent = `Error: ${error.message || 'Route failed'}`;
                dom.statusPanel.classList.remove('hidden');
            } finally {
                dom.loader.classList.add('hidden');
            }
        }

        function startNavigation() {
            if (!state.routeData) return;
            state.isNavigating = true;
            dom.searchContainer.classList.add('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.navigationPanel.classList.remove('hidden');
            dom.directionsContainer.classList.remove('hidden');
            dom.selectorsContainer.classList.add('hidden');
            if (state.destinationMarker) state.destinationMarker.setPopupContent(null);
            const steps = state.routeData.legs && state.routeData.legs[0] && state.routeData.legs[0].steps ? state.routeData.legs[0].steps : [];
            displayDirections(steps);
            updateNavDisplay(state.routeData.distance, state.routeData.duration);
            if (state.etaInterval) clearInterval(state.etaInterval);
            state.etaInterval = setInterval(() => { if (state.isNavigating) updateNavigationProgress(); }, 10000);
        }

        function endNavigation() {
            state.isNavigating = false;
            clearInterval(state.etaInterval);
            state.etaInterval = null;
            if (state.routeLayer) { try { state.map.removeLayer(state.routeLayer); } catch (e) {} }
            if (state.destinationMarker) { try { state.map.removeLayer(state.destinationMarker); } catch (e) {} state.destinationMarker = null; }
            state.routeData = null;
            state.routeLayer = null;
            state.routeLatLngs = [];
            dom.searchContainer.classList.remove('hidden');
            dom.navigationPanel.classList.add('hidden');
            dom.directionsContainer.classList.add('hidden');
            dom.routeSummaryPanel.classList.add('hidden');
            dom.selectorsContainer.classList.remove('hidden');
            dom.statusPanel.classList.remove('hidden');
            dom.statusText.textContent = "Select a destination to begin.";
            if (state.currentLocation) state.map.setView([state.currentLocation.lat, state.currentLocation.lng], 16);
        }

        function loadVoices() { state.voices = speechSynthesis.getVoices(); }

        function startWatchingPosition() {
            const options = { enableHighAccuracy: true, timeout: 7000, maximumAge: 0 };
            try {
                state.watchId = navigator.geolocation.watchPosition(onPositionUpdate, (e) => {
                    dom.statusText.textContent = "GPS signal lost.";
                }, options);
            } catch (e) {
                dom.statusText.textContent = "Unable to start GPS watch.";
            }
        }

        function onPositionUpdate(position) {
            if (!position || !position.coords) return;
            const { latitude, longitude, heading } = position.coords;
            const newLocation = { lat: latitude, lng: longitude };
            state.currentLocation = newLocation;
            if (!state.userMarker) {
                state.map.setView(newLocation, 16);
                const userIconHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><path fill="#3B82F6" d="M232,128A104,104,0,0,1,38.26,169.87L25.47,225.1a16,16,0,0,1-20-20L60.13,192.31A104,104,0,1,1,232,128Z"></path></svg>`;
                state.userMarker = L.marker(newLocation, { icon: L.divIcon({ className: 'user-location-icon', html: userIconHTML, iconSize: [28, 28] }) }).addTo(state.map);
                dom.statusText.textContent = "Select a destination to begin.";
            } else {
                state.userMarker.setLatLng(newLocation);
            }
            if (heading !== null && state.userMarker.getElement) {
                const iconElement = state.userMarker.getElement()?.querySelector('svg');
                if (iconElement) iconElement.style.transform = `rotate(${heading}deg)`;
            }
            if (state.isNavigating) {
                try { state.map.panTo(newLocation, { animate: true }); } catch (e) {}
                updateNavigationProgress();
            }
        }

        // get closest point on polyline and distance traveled along polyline (meters)
        function getClosestPointOnPolyline(pointLatLng, polylineLatLngs) {
            if (!polylineLatLngs || polylineLatLngs.length === 0) return { distanceTraveled: 0, closestLatLng: pointLatLng };

            // Use leaflet-geometryutil to get the closest point on the polyline
            const closest = L.GeometryUtil.closest(state.map, polylineLatLngs, pointLatLng);
            let cumulative = 0;
            let distanceTraveled = 0;
            let found = false;

            for (let i = 0; i < polylineLatLngs.length - 1; i++) {
                const a = polylineLatLngs[i];
                const b = polylineLatLngs[i + 1];
                const segLen = a.distanceTo(b);
                // If closest point lies on this segment, compute distance up to it
                const onSegment = L.GeometryUtil.closestPointOnSegment(state.map, pointLatLng, a, b);
                if (onSegment) {
                    // distance from a to the projection
                    const distAToProj = a.distanceTo(onSegment);
                    // check if projection is actually between a and b (tolerance)
                    if (distAToProj <= segLen + 1e-6) {
                        distanceTraveled = cumulative + distAToProj;
                        found = true;
                        break;
                    }
                }
                cumulative += segLen;
            }

            if (!found) {
                // fallback: distance to first point
                distanceTraveled = 0;
            }

            return { distanceTraveled: distanceTraveled, closestLatLng: closest || pointLatLng };
        }

        function updateNavigationProgress() {
            if (!state.routeLatLngs || state.routeLatLngs.length === 0 || !state.currentLocation || !state.routeData) return;
            const userLatLng = L.latLng(state.currentLocation.lat, state.currentLocation.lng);
            const info = getClosestPointOnPolyline(userLatLng, state.routeLatLngs);
            const remainingDistance = Math.max(0, state.routeData.distance - info.distanceTraveled);
            // routeData.distance (meters) and routeData.duration (seconds)
            const avgSpeed = (state.routeData.duration > 0) ? (state.routeData.distance / state.routeData.duration) : 0; // m/s
            const remainingDurationSeconds = (avgSpeed > 0) ? (remainingDistance / avgSpeed) : 0;
            updateNavDisplay(remainingDistance, remainingDurationSeconds);
        }

        function updateNavDisplay(remainingDistanceMeters, remainingDurationSeconds) {
            const eta = new Date(Date.now() + remainingDurationSeconds * 1000);
            try {
                dom.etaText.textContent = eta.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } catch (e) {
                dom.etaText.textContent = '--:--';
            }
            dom.distanceText.textContent = `${(remainingDistanceMeters / 1000).toFixed(1)} km`;
        }

        function speak(text) {
            if (state.isMuted || !('speechSynthesis' in window) || !text) return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = state.currentLanguage || 'en';
            const voice = state.voices.find(v => v.lang && v.lang.startsWith(state.currentLanguage));
            if (voice) utterance.voice = voice;
            try { window.speechSynthesis.speak(utterance); } catch (e) {}
        }

        function showRouteSummary(route) {
            dom.statusPanel.classList.add('hidden');
            const durationMin = Math.round(route.duration / 60);
            const distanceKm = (route.distance / 1000).toFixed(1);
            dom.summaryDuration.textContent = `${durationMin} min`;
            dom.summaryDistance.textContent = `${distanceKm} km`;
            dom.routeSummaryPanel.classList.remove('hidden');
        }

        function onMapClick(e) {
            if (state.isNavigating) return;
            setDestination(e.latlng);
        }

        function setDestination(latlng) {
            if (state.destinationMarker) {
                state.destinationMarker.setLatLng(latlng);
            } else {
                state.destinationMarker = L.marker(latlng).addTo(state.map);
            }
            if (state.currentLocation) getRoute(state.currentLocation, latlng);
            else dom.statusText.textContent = "Waiting for location to get route.";
        }

        async function performSearch() {
            const query = dom.searchInput.value;
            if (!query || query.length < 3) { dom.searchResults.innerHTML = ''; return; }
            dom.loader.classList.remove('hidden');
            try {
                // Nominatim will often require a User-Agent when used server-side,
                // but client-side requests can work — still handle errors gracefully.
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&accept-language=${state.currentLanguage}`);
                if (!response.ok) throw new Error('Search service returned an error.');
                const data = await response.json();
                dom.searchResults.innerHTML = data.length === 0 ? `<div class="p-3 text-gray-500">No results found.</div>` : data.map(result => `<div class="p-3 border-b border-gray-200 dark:border-gray-700 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" data-lat="${result.lat}" data-lon="${result.lon}"><p class="font-semibold text-gray-800 dark:text-gray-200">${(result.display_name || '').split(',')[0]}</p><p class="text-sm text-gray-500 dark:text-gray-400">${(result.display_name || '').substring((result.display_name || '').indexOf(',') + 1)}</p></div>`).join('');
                dom.searchResults.querySelectorAll('div[data-lat]').forEach(item => item.addEventListener('click', (e) => {
                    setDestination({ lat: parseFloat(e.currentTarget.dataset.lat), lng: parseFloat(e.currentTarget.dataset.lon) });
                    dom.searchInput.value = '';
                    dom.searchResults.innerHTML = '';
                }));
            } catch (error) {
                console.error('Search failed', error);
                dom.searchResults.innerHTML = `<div class="p-3 text-red-500">Search failed.</div>`;
            } finally {
                dom.loader.classList.add('hidden');
            }
        }

        function toggleDarkMode() {
            const isDarkBefore = document.documentElement.classList.contains('dark');
            document.documentElement.classList.toggle('dark');
            const isDark = document.documentElement.classList.contains('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            // swap tile layers safely
            try {
                if (isDark) {
                    if (state.map.hasLayer && state.map.hasLayer(state.lightTileLayer)) state.map.removeLayer(state.lightTileLayer);
                    if (!state.map.hasLayer(state.darkTileLayer)) state.darkTileLayer.addTo(state.map);
                } else {
                    if (state.map.hasLayer && state.map.hasLayer(state.darkTileLayer)) state.map.removeLayer(state.darkTileLayer);
                    if (!state.map.hasLayer(state.lightTileLayer)) state.lightTileLayer.addTo(state.map);
                }
            } catch (e) { /* ignore layer errors */ }
        }

        function toggleMute() {
            state.isMuted = !state.isMuted;
            dom.muteIcon.className = state.isMuted ? 'ph-bold ph-speaker-slash text-2xl' : 'ph-bold ph-speaker-high text-2xl';
            if (!state.isMuted) speak("Voice guidance enabled.");
        }

        function getInstruction(step) {
            if (!step) return '';
            // OSRM step shape: step.maneuver.instruction may not always exist — fallback gracefully
            return step.maneuver && step.maneuver.instruction ? step.maneuver.instruction :
                (step.name ? `Follow ${step.name}` : (step.ref ? `Follow ${step.ref}` : `${step.maneuver?.type || 'Proceed'}`));
        }

        function getManeuverIcon(type, modifier) {
            const icons = {
                'depart': 'ph-navigation-arrow',
                'turn': {
                    'uturn': 'ph-arrow-u-up-left',
                    'sharp right': 'ph-arrow-elbow-right',
                    'right': 'ph-arrow-bend-up-right',
                    'slight right': 'ph-arrow-bend-up-right',
                    'straight': 'ph-arrow-up',
                    'slight left': 'ph-arrow-bend-up-left',
                    'left': 'ph-arrow-bend-up-left',
                    'sharp left': 'ph-arrow-elbow-left',
                },
                'fork': {
                    'right': 'ph-git-fork',
                    'left': 'ph-git-fork',
                    'straight': 'ph-arrow-up'
                },
                'end of road': 'ph-sign-t',
                'use lane': 'ph-arrow-line-up',
                'merge': 'ph-arrows-merge',
                'ramp': 'ph-arrow-up-right',
                'roundabout': 'ph-radio-button',
                'rotary': 'ph-radio-button',
                'continue': 'ph-arrow-up',
                'arrive': 'ph-check-circle',
                'new name': 'ph-arrow-up',
                'default': 'ph-question'
            };
            let iconClass = icons.default;
            if (icons[type]) {
                if (typeof icons[type] === 'string') iconClass = icons[type];
                else if (typeof icons[type] === 'object' && modifier && icons[type][modifier]) iconClass = icons[type][modifier];
                else if (typeof icons[type] === 'object') iconClass = icons[type]['straight'] || Object.values(icons[type])[0];
            }
            return `<i class="ph-bold ${iconClass}"></i>`;
        }

        function displayDirections(steps) {
            if (!steps || steps.length === 0) {
                dom.directionsPanel.innerHTML = `<div class="p-3 text-gray-500">No directions available.</div>`;
                return;
            }
            const firstStep = steps[0];
            const firstInstruction = getInstruction(firstStep);
            // distance for speech: round meters
            speak(`In ${Math.round(firstStep.distance || 0)} meters, ${firstInstruction}`);
            dom.nextManeuverIcon.innerHTML = getManeuverIcon(firstStep.maneuver?.type || 'default', firstStep.maneuver?.modifier);
            dom.nextManeuverDist.textContent = `${Math.round(firstStep.distance || 0)} m`;
            dom.nextManeuverText.textContent = firstInstruction;
            dom.directionsPanel.innerHTML = '<ul>' + steps.map(step => {
                const dist = (step.distance && step.distance > 999) ? `${(step.distance / 1000).toFixed(1)} km` : `${(step.distance || 0).toFixed(0)} m`;
                return `<li class="py-2 border-b border-gray-100 dark:border-gray-700 flex items-center gap-3"><span class="text-2xl">${getManeuverIcon(step.maneuver?.type || 'default', step.maneuver?.modifier)}</span><span class="flex-grow">${getInstruction(step)}</span><span class="font-semibold text-blue-500">${dist}</span></li>`;
            }).join('') + '</ul>';
        }

        window.onload = initMap;
    </script>
</body>
</html>
